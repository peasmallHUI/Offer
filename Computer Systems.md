 深入理解计算机系统
 ======
 [toc]
 ------

# 第一章 计算机系统漫游

## 一、信息就是：位+上下文
- 文本文件：只由ASCII码构成的文件；其他的称为二进制文件  
- 系统中所有信息都是由一串比特表示区别其方法是依据上下文  


## 二、程序被其他程序翻译成不同的格式

- 预处理阶段
    > 预处理器(cpp)根据字符#开头的命令，修改原始程序，得到hello.i程序文本
    
- 编译阶段
    > 编译器(ccl)将hello.i翻译成hello.s文件。包含一个汇编语言程序(main的定义)

- 汇编阶段
    > 汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成*可重定位目标程序*(hello.o)，它是一个二进制文件，包含的17个字节是函数main的指令编码

- 链接阶段
    > 链接器(ld)负责程序之间的合并，结果得到*可执行目标文件*


## 三、了解编译系统如何工作是大有益处的

- 优化程序性能

- 理解链接时出现的错误

- 避免安全漏洞


## 四、处理器读并解释储存内存中的指令

1. 系统的硬件组成
    - 总线
        > 贯穿整个系统的一组电子管道
    - I/O设备
        > 系统与外部世界的联系通道
    - 主存(DRAM)
        > 执行程序时，存放程序和程序处理的数据
    - 处理器
        > 程序计数器(PC,一字节)  
        > 算术单元(ALU)

2. 运行hello程序
    - shell程序 -> 键盘输入 -> I/O桥 -> 总线接口 -> 寄存器 -> 主存  
    - 磁盘 -> 磁盘控制器 -> I/O桥 -> 主存  (DMA)  
    - 主存 -> I/O桥 -> 总线接口 -> 寄存器 -> 总线接口 -> I/O桥 -> 图形适配器  
    

## 五、高速缓存至关重要
- 较小存储设备速度快，造价高;较大存储设备容量大，造价低  


## 六、存储设备形成层次结构
- L0:寄存器；L1高速缓存(SRAM)；L2高速缓存；L3高速缓存；主存；本地二级存储；远程二级存储  


## 七、操作系统管理硬件
- 操作系统两个基本功能：防止硬件被失控的应用程序滥用；向应用程序提供简单一致的机制控制硬件设备  
1. 进程 
    - 正在运行的程序的一种抽象；提供一种假象，好像系统上只有这个程序独占  
    - 上下文：操作系统保持跟踪进程运行所需的所有状态信息  
    - 进程的转换是由操作系统内核管理；内核是操作系统代码常驻主存的部分  

2. 线程
    - 一个进程可以由多个线程组成；它是执行调度的基本单位  
    - 线程间更容易共享数据

3. 虚拟内存
    - 为进程提供假象，每个进程独占使用主存；*虚拟地址空间*
    - 程序代码和数据 -> 堆 -> 共享库 -> 栈 -> 内核虚拟内存
4. 文件
    - 文件就是字节序列，I/O设备都可以看成是文件


## 八、系统之间利用网络通信
- 网络可视为一个I/O设备


## 九、重要主题
- 系统是硬件和系统软件互相交织的集合体
1. Amdahl定律
    - 提升系统部分性能带来的效果：S = 1/[(1-a) + a/k ]
    
    - 练习题1.1
        > S = 1/[(1-0.6) + 0.6/1.5] = 1.25  
        > k = 0.6 / (1/s - 0.4) = 3  

    - 练习题1.2
        > k = 0.8 / (1/s - 0.2) = 2.67

2. 并发和并行
    - 并发：同时具有多个活动的系统  
    - 并行：用并发使系统运行更快   
    - 超线程：CPU某些硬件有多个备份(程序计数器和寄存器文件)，而其他硬件部分只有一份(浮点算术运算)  
    - 线程级并行；指令级并行；单指令、多数据并行  

3. 计算机系统中抽象的重要性
    - 文件：I/O设备  
    - 主存：虚拟内存  
    - 处理器：指令级架构  
    - 程序：进程  
    - 计算机：虚拟机  


## 十、小结
- 计算机系统：硬件 + 软件  
- 信息：位 + 上下文  
- 程序执行：编译、链接  
- 存储设备：层次结构  
- 内核：应用程序和硬件的媒介  
- 系统抽象：文件、虚拟内存、进程  


# 第二章 信息的表示和处理

## 一、信息存储

1. 十六进制表示法
    - 两个十六进制表示一个八位的字节`0xf5`
    
    - 练习2.1/2.2/2.3/2.4
        > 数制转换

2. 字数据大小
    - 字长：指针数据的标称大小，虚拟地址的范围  
    - 可移植：数据类型有确切大小  

3. 寻址和字节顺序
    - 多字节对象地址：使用字节中最小的地址  
    - 存储方式：小端法：最低有效字节在前、大端法：最高有效位在前  

    - 练习题2.5/2.6
        > 大小端法；浮点数和整型重合

4. 表示字符串
    - 以null结尾的字符数组(ASCII)  

5. 表示代码
    - 只是一种字节序列，二进制代码不兼容  

6. 布尔代数简介
    - 位运算，或，与，非，异或  

    - 练习题2.8/2.9 
        > 位运算

7. C语言中的位级运算
    - | & ~ ^

    - 练习题2.10
        > 异或交换
        ```c++
        y = x^y;
        x = x^y;
        y = x^y;
        ```

    - 练习题2.11
        > 奇数数组交换中间值不用改变

    - 练习题2.12
        > 掩码  
        > 最低字节：0xFF & x  
        > 除了最低位，其他取反：(~0 - 0xFF)^x  
        > 最低设为1，其他不变：0xFF | x  

    - 练习题2.13
        > 位设置/位清除  
        > 或：bis(x,y)  
        > 异或：bis(bic(x, y), bic(y, x))  

8. C语言中的逻辑运算
    - `||`, `&&`, `！`  

    - 练习题2.14/2.15
        > 逻辑运算

9. C语言中的移位运算
    - 左移/右移(逻辑/算术)    
    - `<<`, `>>`  

    - 练习题2.16 
        > 移位运算(优先级低于加减法)


## 二、整数表示

1. 整型数据类型
    - `char`，`short`，`int`，`long`，`unsigned`

2. 无符号的编码  
    - $B 2 U_{w}(\vec{x}) \doteq \sum_{i=0}^{w-1} x_{i} 2^{i}$

3. 补码表示
    - $B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i}$
    
    - 练习题2.17/2.18
        > 补码/原码计算
    
4. 有符号和无符号数之间的转换
    - $T 2 U_{w}(x) \doteq B 2 U_{w}\left(T 2 B_{w}(x)\right)$

    - 练习题2.19/2.20
        > 补码与无符号相互转换    
        > $T 2 U_{w}(x)=\left\{\begin{array}{ll}{x+2^{w},} & {x<0} \\ {x,} & {x \geqslant 0}\end{array}\right.$  
        > $U 2 T_{w}(u)=\left\{\begin{array}{ll}{u,} & {u \leqslant T M a x_{w}} \\ {u-2^{w},} & {u>\operatorname{TMax}_{w}}\end{array}\right.$   

5. C语言中的有符号数与无符号数
    - 隐式/显式

    - 练习题2.21
        > 强制类型转换

6. 扩展一个数字的位表示
    - 无符号的零扩展
    
    - 补码数的符号扩展

    - 练习题2.22/2.23
        > 符号扩展
    
7. 截断数字
    - 截断无符号数
        > $x^{\prime}=x \bmod 2^{k}$
    
    - 截断补码数值
        > $x^{\prime}=U 2 T_{k}\left(x \bmod 2^{k}\right)$
    
    - 练习题2.24
        >截断值
    
8. 关于有符号数与无符号数的建议
    - 练习题2.25/2.26
        > `unsigned int`小于零，参数不匹配
    

## 三、整数运算

1. 无符号加法
    - 字长膨胀

    - $x+_{w}^{u} y=\left\{\begin{array}{ll}{x+y,} & {x+y<2^{w}} \\ {x+y-2^{w},} & {2^{w} \leqslant x+y<2^{w+1}}\end{array}\right.$

    - 溢出斜面(s < x)

    - 练习题2.27
        > 溢出判断(s > x)

    - 练习题2.28
        > 模数加法构成阿贝尔群  
        > 逆元 $-_{w}^{v} x=\left\{\begin{array}{ll}{x,} & {x=0} \\ {2^{w}-x,} & {x>0}\end{array}\right.$
    
2. 补码加法
    - $x+_{w}^{t} y=\left\{\begin{array}{ll}{x+y-2^{w},} & {2^{w-1} \leqslant x+y} \\ {x+y,} & {-2^{u-1} \leqslant x+y<2^{u-1}} \\ {x+y+2^{w},} & {x+y<-2^{w-1}}\end{array}\right.$

    - 溢出检测
        > x>0, y>0, s<=0   正溢出  
        > x>0, y>0, s>=0   负溢出
    
    - 练习题2.29/2.30/2.31
        > 补码加法，溢出检测
    
    - 练习题2.32
        > x-y溢出判断  
        > **Tmin**时 -y = y  
    
3. 补码的非
    - $-_{u}^{+} x=\left\{\begin{array}{ll}{\operatorname{TMin}_{w},} & {x=\operatorname{TMin}_{w}} \\ {-x,} & {x>\operatorname{TMin}_{w}}\end{array}\right.$

    - 练习题2.33
        >补码的逆元[^1]

        [^1]: 逆元与原数相加为零 `-x = ~x + 1`

4. 无符号的乘法
    - $x * \underset{w}{u} y=(x \cdot y) \bmod 2^{w}$

5. 补码乘法
    - $x *_{w}^{t} y=U 2 T_{w}\left((x \cdot y) \bmod 2^{w}\right)$

    - 练习题2.34
        > 乘法计算
    
    - 练习题2.35
        > 乘法溢出的检测  
        > `return !x || p/x == y`  
        > x = 0 ,正确  
        > p:补码结果，q:p除以x  
        > $x \cdot y=p+t 2^{w}$  
        > $p=x \cdot q+r, 其中 |r|<|x|$  
        > q=y,当且仅当 r=t=0  
    
    - 练习题2.36
        > 乘法溢出，非除法  
    
    - 练习题2.37
        > 乘法溢出
    
 6. 乘以常数
    > 用移位和加减法运算组合成乘法
    
    - 乘以2的幂
        > 左移等价乘以2的幂

    - 练习题2.38
        > `(a<<k) + b`
    
    - 练习题2.39  
        > $[(0 \cdots 0)(1 \cdots 1)(0 \cdots 0) \cdots(1 \cdots 1)]$  
        > $(\mathrm{x} << n)+(\mathrm{x}<<(n-1))+\dots+(\mathrm{x}<<\mathrm{m})$ 
        $(\mathrm{x}<<(n+1))-(\mathrm{x}<<\mathrm{m})$

    - 练习题2.40/2.41
        > 移位加减法计算 

7. 除以2的幂
    - 逻辑移位和算术移位

    - 向下舍入/向上舍入

    - 无符号除法，逻辑右移

    - 补码除法，算术右移
        > 算术右移，向下舍入  
        > 偏置右移(( x+(1 << k)-1 )>> k)，向上舍入  
        > $(x<0 ? x+(1<< k)-1 : x)>>k$  
    
    - 练习题2.42
        > div16  
        ```c++ 
        int div16(int x)
        {
            int bias = (x >> 31) & 0xF;
            return (x + bias) >>4;
        }
        ```
    
    - 练习题2.43
        > M = 31, N = 8
    
8. 关于整数运算的最后思考
    - 模运算
    - 溢出
    - 练习题2.44
        > x = Tmin  
        > true  
        > x = 2^16  
        > true  
        > x = Tmin  
        > x = y = Tmin  
        > 


## 四、浮点数

1. 二进制小数
    - $b=\sum_{i=-n}^{m} 2^{i} \times b_{i}$

    - 刚好小于1：$1.0-\varepsilon$

    - 练习题2.45/2.46
        > 进制的小数转换

2. IEEE浮点表示
    - $V=(-1)^{s} \times M \times 2^{E}$
        > 符号(s):正负区分  
        > 尾数(M):二进制小数  
        > 阶数(E):浮点数的加权  
    
    - C语言中位数分配
        > float:1/8/23  
        > double:1/11/52
    
    - 规格化的值
        > exp不全为1/0  
        > 阶码值 E = e - Bias 
        > 尾数 M = 1 + f，隐含一  
    
    - 非规格化的值
        > 表示0，M = f  
        > 表示非常接近于0.0的数  
        > exp全为0  
        > E = 1 - Bias[^2]

        [^2]:这种方式提供了一种从非规格化值平滑转换到规格化值的方法  
        
    - 特殊值
        > exp全为1  
        > 小数域全为0，表示无穷  
        > 无穷表示溢出  `NaN`  
    
3. 数字示例
    - 练习题2.47
        > 浮点数数值计算  
    
    - 浮点的一般属性  
        > 值+0.0总有一个全为0的位表示  
        > 最小的正非规格化值，最低位为1，$V=2^{-n-2^{k-1}+2}$  
        > 最大的非规格化值，全为0的阶码，全为1的小数字段，$V=\left(1-2^{-n}\right) \times 2^{-2^{k-1}+2}$  
        > 最小的正规格化值，阶码最低位为1，$V=2^{-2^{k-1}+2}$  
        > 值1.0，阶码段除了最高位其余为1  
        > 最大的规格化值，阶码段最低位为0，$V=\left(2-2^{-n}\right) \times 2^{2^{k-1}-1}=\left(1-2^{-n-1}\right) \times 2^{2^{k-1}}$  
    
    - 练习题2.48
        > 浮点数的转换
    
    - 练习题2.49
        > n位小数的浮点格式，不能准确描述的最小正整数其二进制形式为1,n*0,1 即2^(n+1)+1
    
4. 舍入
    - 向偶舍入

    - 练习题2.50/2.51
        > 舍入  
    
    - 练习题2.52  
        > IEEE格式浮点数  
    
5. 浮点运算
    - $\operatorname{Round}(x \odot y)$  
        > 浮点加法不具有结合性  
        > 浮点加法满足单调性  
        > 浮点乘法不具备结合性、分配性  
    
6. C语言中的浮点数
    - `float`, `double`
    - 练习题2.53
        > 生成双精度无穷和0  
    
    - 练习题2.54
        > 类型转换`int`, `float`, `double`
    
## 五、小结

- 编码为位(比特)，组织成字节序列
- 不同编码方式表示整数、实数
- 补码编码、IEEE浮点数
- 强制转换时底层位模式不变 
- 有限长度引起数值溢出
- 浮点运算的属性问题  

## 家庭作业
- 2.58
    > is_little_endian
    ```c++
    bool is_little_endian()
    {
        union xiaoduan
        {
            int a;
            char b;
        } x;
        x.a = 0x01234567;
        return 0x01 == x.b; 
    }
    ```


# 第三章 程序的机器级表示

## 一、历史观点

- x86

- 摩尔定律


## 二、程序编码

1. 机器级代码
    - 两种抽象模型：ISA(指令集架构)、内存

    - 程序计数器(PC)：下一条指令在内存的位置

    - 整数寄存器：存储地址、整型、临时数据

    - 条件码寄存器：最近执行的算术或逻辑指令

    - 